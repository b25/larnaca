<#@ template language="C#" hostspecific="True" Type="DB" Replication="Project" #>
<#@ output extension=".g.cs"#>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ assembly name="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ assembly name="netstandard.dll" #>
<#@ assembly name="$(SolutionDir)\bin\$(ConfigurationName)\netcoreapp3.1\Newtonsoft.Json.dll" #>
<#@ import namespace="Newtonsoft.Json" #>
<#@ assembly name="$(SolutionDir)\bin\$(ConfigurationName)\netcoreapp3.1\mssql.collector.types.dll" #>
<#@ import namespace="mssql.collector.types" #>
<#@ assembly name="$(SolutionDir)\bin\$(ConfigurationName)\netcoreapp3.1\gen.utils.dll" #>
<#@ import namespace="gen.utils" #>

<#
    //the dbMeta is provided by the Larnaca.Project.Tools 
    //uncomment when using the default T4 generation
    //var projectPath = Host.ResolvePath("../../obj");
    //string resultFile = Path.Combine(projectPath,"result.json");
    //DatabaseMeta dbMeta;
    //if (File.Exists(resultFile))
    //{
    //    dbMeta=JsonConvert.DeserializeObject<DatabaseMeta>(File.ReadAllText(resultFile));
    //}
    //else
    //{
    //    dbMeta=new DatabaseMeta{Name="could_not_found_the_result_file",Procedures=new ProcedureMeta[0] };
    //}
#>
<#@ parameter name="dbMeta" type="mssql.collector.types.DatabaseMeta" #>

// <auto-generated>
//     This code was generated  at <#=        DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff") #> 
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Data;
using System.Data.SqlClient;
using System.Threading.Tasks;
using System.Runtime.Serialization;
using ProtoBuf;
using collection.extensions;

namespace mssql.adapter.<#= DalUtils.ToPascalCase(dbMeta.Name) #>
{

<#    foreach (var proc in dbMeta.Procedures){ #>

#region <#= $"{DalUtils.GetBaseClassName(proc.SpName)}Response"#> .. 
[DataContract]
public partial class <#=$"{DalUtils.GetBaseClassName(proc.SpName)}Response"#>
{
    [DataMember(Order = 1)]
    public int StatusCode { get; set; }

    [DataMember(Order = 2)]
    public string StatusMessage { get; set; } 

 <#foreach (var param in proc.Responses.Where(x=>(x.Order>0))){ #>
    [DataMember(Order = <#= param.Order #>)]
    public List<<#=$"{DalUtils.GetBaseClassName(proc.SpName)}Item{(param.Order-2)}"#>> <#= param.Name #> { get; set; }

 <#}#>
 
 
 <#if (proc.Responses.Any(x=>(x.Order>0))){ #>
    #region inner classes .. 
     <#foreach (var param in proc.Responses.Where(x=>(x.Order>0))){ #>

    [DataContract]
    public class <#=$"{DalUtils.GetBaseClassName(proc.SpName)}Item{(param.Order-2)}"#>
    {
        <#foreach (var p in param.Params){ 
         var memberType= DalUtils.GetCSharpNullableFriendlyType(p.SqlType,null);
         var memberName= DalUtils.ToPascalCase(p.Name);
#>

   <#= memberType #> _<#= memberName#>;
   [DataMember(Order = <#= p.Order #>)]
   public <#=memberType #> <#= memberName#> { get { return _GetNullableValue(_<#= memberName#>, <#= p.Order#>); } set { _<#= memberName#> = value; _SetNullable(_<#= memberName#>==null,<#= p.Order#>); } }

         <# }#>
      
    #region nullable hack...
 
   private BitArray _InternalNullFields;
   private static int _MaxOrder=<#= param.Params.Max(x=>x.Order) #>;
   
   [DataMember(Order = 10000)]
   public byte[] InternalNullFields { get{ return _InternalNullFields.ToBytes();} set{ if (value != null) { _InternalNullFields = new BitArray(value); } else { _InternalNullFields = null; }; } }

   
  private void _SetNullable(bool isNullValue, int order)
  {
    if (_InternalNullFields == null && !isNullValue) return;
    if (order > _MaxOrder) throw new Exception($"_SetNullable{order} is greater than MaxOrder: {_MaxOrder}");
    if (_InternalNullFields == null) _InternalNullFields = new BitArray(_MaxOrder);
    _InternalNullFields.Set(order-1, isNullValue);          
      
  }

  private  T? _GetNullableValue<T>(T? value, int order) where T: struct
  {
     if (order > _MaxOrder) throw new Exception($"_SetNullable Invalid Generation Order{order} is greater than max order{_MaxOrder} ");
     if (_InternalNullFields == null) return value.GetValueOrDefault();
     if (_InternalNullFields.Get(order-1)) return null;
     return value.GetValueOrDefault();
  }

  private  T[] _GetNullableValue<T>(T[] value, int order) where T: struct
  {
     if (order > _MaxOrder) throw new Exception($"_SetNullable Invalid Generation Order{order} is greater than max order{_MaxOrder} ");
     if (_InternalNullFields == null) return value ?? Array.Empty<T>();
     if (_InternalNullFields.Get(order-1)) return null;
     return value ?? Array.Empty<T>();
  }

  private  string _GetNullableValue(string value, int order)
  {
     if (order > _MaxOrder) throw new Exception($"_SetNullable Invalid Generation Order{order} is greater than max order{_MaxOrder} ");
     if (_InternalNullFields == null) return value ?? string.Empty;
     if (_InternalNullFields.Get(order-1)) return null;
     return value ?? string.Empty;
  }

#endregion
 
    }
    <#}#> 
    #endregion
 <#}#>
 
}
#endregion

<#    } //end foreach dbMeta.Procedures #>
  
     
}

<#@ template language="C#" hostspecific="True" #>
<#@ output extension=".js"#>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ assembly name="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ assembly name="netstandard.dll" #>
<#@ assembly name="$(SolutionDir)\bin\$(ConfigurationName)\netcoreapp3.1\Newtonsoft.Json.dll" #>
<#@ import namespace="Newtonsoft.Json" #>
<#@ assembly name="$(SolutionDir)\bin\$(ConfigurationName)\netcoreapp3.1\mssql.collector.types.dll" #>
<#@ import namespace="mssql.collector.types" #>
<#@ assembly name="$(SolutionDir)\bin\$(ConfigurationName)\netcoreapp3.1\gen.utils.dll" #>
<#@ import namespace="gen.utils" #>
<#
//collection generation info    
//todo replace later 
var projectPath = Host.ResolvePath("../../obj");
string resultFile = Path.Combine(projectPath,"result.json");
DatabaseMeta dbMeta;
if (File.Exists(resultFile))
{
    dbMeta=JsonConvert.DeserializeObject<DatabaseMeta>(File.ReadAllText(resultFile));
}
else
{
    dbMeta=new DatabaseMeta{Name="could_not_found_the_result_file",Procedures=new ProcedureMeta[0] };
}  
#>
// <auto-generated>
//     This code was generated at <#= DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff") #> 
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// package: mssql.adapter.<#= DalUtils.ToPascalCase(dbMeta.Name) #>
// file: service.proto

/* tslint:disable */
/* eslint-disable */

"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = {};
const service_pb = __importDefault(require("./service_pb"));
const global = Function('return this')();

<#
Action<int> outputConstructor = (int maxOrder) => {
#>
    constructor() {
        super();
        this._areNullablesEnabled = true;
        const nullFields = this._getNullables();
        this.setInternalnullfields(nullFields);
    }
    _getNullables() {
        let nullFields = this.getInternalnullfields_asU8();
        if (!nullFields || nullFields.byteLength === 0) {
            const totalBytes = <#= Math.Ceiling((double)maxOrder/8) #>;
            nullFields = new Uint8Array(totalBytes);
            nullFields.fill(255, 0, totalBytes);
        }
        return nullFields;
    }
    _isNullValue(order) {
        if (!this._areNullablesEnabled) {
            return false;
        }
        const nullFields = this._getNullables();
        const n = order - 1;
        return (nullFields[n / 8 | 0] & 1 << n % 8) != 0;
    }
    _getNullableValue(value, order) {
        if (this._isNullValue(order)) {
            return undefined;
        }
        return value;
    }
    _setNullableValue(isNullValue, order) {
        if (!this._areNullablesEnabled) {
            return;
        }
        const nullFields = this._getNullables();
        const n = order - 1;
        if (isNullValue) {
            nullFields[n / 8 | 0] |= 1 << n % 8;
        }
        else {
            nullFields[n / 8 | 0] &= ~(1 << n % 8);
        }
        this.setInternalnullfields(nullFields);
    }
    static serializeBinaryToWriter(message, writer) {
        message._areNullablesEnabled = false;
        super.serializeBinaryToWriter(message, writer);
        message._areNullablesEnabled = true;
    }
    static deserializeBinaryFromReader(msg, reader) {
        const nullFields = msg.getInternalnullfields_asU8();
        nullFields.fill(0, 0, nullFields.byteLength);
        msg.setInternalnullfields(nullFields);
        msg._areNullablesEnabled = false;
        super.deserializeBinaryFromReader(msg, reader);
        msg._areNullablesEnabled = true;
        return msg;
    }
<#
};

Action<string, int> outputHas = (string field, int order) => {
#>
    has<#= field #>() {
        return super.has<#= field #>() && !this._isNullValue(<#= order #>);
    }
<#
};

Action<string, int> outputClear = (string field, int order) => {
#>
    clear<#= field #>() {
        super.clear<#= field #>();
        this._setNullableValue(true, <#= order #>);
    }
<#
};

Action<string, int> outputGetter = (string field, int order) => {
#>
    get<#= field #>() {
        return this._getNullableValue(super.get<#= field #>(), <#= order #>);
    }
<#
};

Action<string, int> outputSetter = (string field, int order) => {
#>
    set<#= field #>(value) {
        super.set<#= field #>(value);
        this._setNullableValue(typeof value === "undefined", <#= order #>);
        return this;
    }
<#
};

Action<string, string> outputObject = (string name, string sqlType) => {
    var paramName=DalUtils.ToProtoCase(name);
    var memberName=DalUtils.ToLowerFirst(paramName);

    if (sqlType == "structured")
    {
#>
            <#= memberName #>List: (_a = msg.get<#= paramName #>List()) === null || _a === void 0 ? void 0 : _a.toObject(includeInstance),
<#
    }
    else if (DalUtils.IsDatetime(sqlType))
    {
#>
            <#= memberName #>: (_a = msg.get<#= paramName #>()) === null || _a === void 0 ? void 0 : _a.toObject(includeInstance),
<#
    }
    else
    {
#>
            <#= memberName #>: msg.get<#= paramName #>(),
<#
    }
};

var protoNamespace=$"global.proto.mssql.adapter.{DalUtils.ToPascalCase(dbMeta.Name)}";

Action<string> outputExport = (string className) => {
#>
exports.<#= className #> = <#= className #>;
exports.default.<#= className #> = <#= className #>;
<#= protoNamespace #>.<#= className #> = <#= className #>;
<#
};

foreach (var proc in dbMeta.Procedures)
{
    var baseClassName=DalUtils.GetBaseClassName(proc.SpName);
#>
class <#= $"{baseClassName}Request" #> extends service_pb.default.<#= $"{baseClassName}Request" #> {
<#
    outputConstructor(proc.Request.Max(x=>x.Order));
#>

<#
    foreach (var param in proc.Request)
    {
        if (param.TVP!=null)
        {
            continue;
        }

        var memberType=DalUtils.GetJavascriptFriendlyType(param.SqlType,$"TVP{param.Name}");
        var memberName=DalUtils.ToProtoCase(param.Name);

        if (DalUtils.IsDatetime(param.SqlType))
        {
            outputHas(memberName, param.Order);
            outputClear(memberName, param.Order);
        }

        outputGetter(memberName, param.Order);
        outputSetter(memberName, param.Order);
#>

<#
    } //end foreach proc.Request
#>
    static toObject(includeInstance, msg) {
        let _a;
        const obj = {
<#
    foreach (var param in proc.Request)
    {
        outputObject(param.Name, param.TVP!=null ? "structured" : param.SqlType);
    }
#>
        };

        if (includeInstance) {
            obj.$jspbMessageInstance = msg;
        }
        return obj;
    }
}
<#
    outputExport($"{baseClassName}Request");
#>

<#
    foreach (var param in proc.Request.Where(x => x.TVP!=null))
    {
#>
class <#= $"TVP{param.Name}" #> extends service_pb.default.<#= $"TVP{param.Name}" #> {   
<#
        outputConstructor(param.TVP.Max(x=>x.Order));
#>

<#
        foreach (var p in param.TVP)
        { 
            var memberType=DalUtils.GetJavascriptFriendlyType(p.SqlType,null);
            var memberName=DalUtils.ToProtoCase(p.Name);

            if (DalUtils.IsDatetime(p.SqlType))
            {
                outputHas(memberName, p.Order);
                outputClear(memberName, p.Order);
            }

            outputGetter(memberName, p.Order);
            outputSetter(memberName, p.Order);
#>

<#
        } //end foreach param.TVP
#>
    static toObject(includeInstance, msg) {
        let _a;
        const obj = {
<#
        foreach (var p in param.TVP)
        {
            outputObject(p.Name, p.SqlType);
        }
#>
        };

        if (includeInstance) {
            obj.$jspbMessageInstance = msg;
        }
        return obj;
    }
}
<#
        outputExport($"TVP{param.Name}");
#>

<#
    } //end foreach proc.Request.TVP
#>

class <#= $"{baseClassName}Response" #> extends service_pb.default.<#= $"{baseClassName}Response" #> {
<#
    foreach (var param in proc.Responses.Where(x=>(x.Order>0)))
    {
        var memberType=$"{baseClassName}Item{(param.Order-2)}";
        var memberName=DalUtils.ToProtoCase(param.Name);
    } //end foreach proc.Responses #>
}
<#
    outputExport($"{baseClassName}Response");
#>

<#
    if (proc.Responses.Any(x=>(x.Order>0)))
    {
        foreach (var param in proc.Responses.Where(x=>(x.Order>0)))
        { 
            var responseParamClassName=$"{baseClassName}Item{(param.Order-2)}";
#>
class <#= responseParamClassName #> extends service_pb.default.<#= responseParamClassName #> {
<#
            outputConstructor(param.Params.Max(x=>x.Order));
#>

<#
            foreach (var p in param.Params)
            { 
                var memberType=DalUtils.GetJavascriptFriendlyType(p.SqlType,null);
                var memberName=DalUtils.ToProtoCase(p.Name);

                if (DalUtils.IsDatetime(p.SqlType))
                {
                    outputHas(memberName, p.Order);
                    outputClear(memberName, p.Order);
                }

                outputGetter(memberName, p.Order);
                outputSetter(memberName, p.Order);
#>

<#
            } //end foreach param.Params
#>
    static toObject(includeInstance, msg) {
        let _a;
        const obj = {
<#
            foreach (var p in param.Params)
            {
                outputObject(p.Name, p.TVP!=null ? "structured" : p.SqlType);
            }
#>
        };

        if (includeInstance) {
            obj.$jspbMessageInstance = msg;
        }
        return obj;
    }
}
<#
            outputExport(responseParamClassName);
        } //end foreach proc.Responses
    } //end if proc.Responses
} //end foreach dbMeta.Procedures
#>

<#@ template language="C#" hostspecific="True" #>
<#@ output extension=".g.cs"#>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ assembly name="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ assembly name="netstandard.dll" #>
<#@ assembly name="$(SolutionDir)\bin\$(ConfigurationName)\netcoreapp3.1\Newtonsoft.Json.dll" #>
<#@ import namespace="Newtonsoft.Json" #>
<#@ assembly name="$(SolutionDir)\bin\$(ConfigurationName)\netcoreapp3.1\mssql.collector.types.dll" #>
<#@ import namespace="mssql.collector.types" #>
<#@ assembly name="$(SolutionDir)\bin\$(ConfigurationName)\netcoreapp3.1\gen.utils.dll" #>
<#@ import namespace="gen.utils" #>
<#
//collection generation info    
//todo replace later 
var projectPath = Host.ResolvePath("../obj");
string resultFile = Path.Combine(projectPath,"result.json");
DatabaseMeta dbMeta;
if (File.Exists(resultFile))
{
    dbMeta=JsonConvert.DeserializeObject<DatabaseMeta>(File.ReadAllText(resultFile));
}
else
{
    dbMeta=new DatabaseMeta{Name="could_not_found_the_result_file",Procedures=new ProcedureMeta[0] };
}

var listedTVP = new HashSet<string>();
#>
// <auto-generated>
//     This code was generated at <#= DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff") #> 
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Data;
using System.Data.SqlClient;
using System.Threading.Tasks;
using System.Runtime.Serialization;
using ProtoBuf;
using collection.extensions;

namespace mssql.adapter.<#= DalUtils.ToPascalCase(dbMeta.Name) #>
{
<#
foreach (var proc in dbMeta.Procedures) {
#>
    #region <#= $"{DalUtils.GetBaseClassName(proc.SpName)}Request"#> .. 
    [DataContract]
    public partial class <#= $"{DalUtils.GetBaseClassName(proc.SpName)}Request"#>
    {
<#
    foreach (var param in proc.Request)
    { 
        string memberType;

        if(param.TVP!=null)
        {
            var t=DalUtils.GetCSharpNullableFriendlyType("structured",$"TVP{param.Name}");
            memberType=$"List<{t}>";
        }
        else
        {
            memberType=DalUtils.GetCSharpNullableFriendlyType(param.SqlType,$"TVP{param.Name}");
        }

        var memberName=DalUtils.ToPascalCase(param.Name);
#>
        <#= memberType #> _<#= memberName#>;
        [DataMember(Order = <#= param.Order #>)]
<#
        if(param.TVP==null)
        {
#>   
        public <#=memberType #> <#= memberName#> { get { return _GetNullableValue(_<#= memberName#>, <#= param.Order#>); } set { _<#= memberName#> = value; _SetNullable(_<#= memberName#>==null,<#= param.Order#>); } }

<#
        }
        else
        {
#>
        public <#=memberType #> <#= memberName#> { get; set; }

<#
        }
    } //end foreach proc.Request
#>

        #region nullable hack...
        private BitArray _InternalNullFields;
        private static int _MaxOrder=<#= proc.Request.Select(x=>x.Order).DefaultIfEmpty().Max() #>;

        [DataMember(Order = 10000)]
        public byte[] InternalNullFields { get{ return _InternalNullFields.ToBytes();} set{ if (value != null) { _InternalNullFields = new BitArray(value); } else { _InternalNullFields = null; }; } }
   
        private void _SetNullable(bool isNullValue, int order)
        {
            if (_InternalNullFields == null && !isNullValue) return;
            if (order > _MaxOrder) throw new Exception($"_SetNullable{order} is greater than MaxOrder: {_MaxOrder}");
            if (_InternalNullFields == null) _InternalNullFields = new BitArray(_MaxOrder);
            _InternalNullFields.Set(order-1, isNullValue);
        }

        private T? _GetNullableValue<T>(T? value, int order) where T: struct
        {
            if (order > _MaxOrder) throw new Exception($"_SetNullable Invalid Generation Order{order} is greater than max order{_MaxOrder} ");
            if (_InternalNullFields == null) return value.GetValueOrDefault();
            if (_InternalNullFields.Get(order-1)) return null;
            return value.GetValueOrDefault();
        }

        private T[] _GetNullableValue<T>(T[] value, int order) where T: struct
        {
            if (order > _MaxOrder) throw new Exception($"_SetNullable Invalid Generation Order{order} is greater than max order{_MaxOrder} ");
            if (_InternalNullFields == null) return value ?? Array.Empty<T>();
            if (_InternalNullFields.Get(order-1)) return null;
            return value ?? Array.Empty<T>();
        }

        private string _GetNullableValue(string value, int order)
        {
            if (order > _MaxOrder) throw new Exception($"_SetNullable Invalid Generation Order{order} is greater than max order{_MaxOrder} ");
            if (_InternalNullFields == null) return value ?? string.Empty;
            if (_InternalNullFields.Get(order-1)) return null;
            return value ?? string.Empty;
        }
        #endregion
    }
    #endregion

<#
    foreach (var param in proc.Request.Where(x => x.TVP!=null))
    {
        var className=$"TVP{param.Name}";

        if (!listedTVP.Add(className)) continue;
#>
    #region <#= className #> ..    
    [DataContract]
    public class <#= className #>
    {   
<#
        foreach (var p in  param.TVP)
        {
            var memberType=DalUtils.GetCSharpNullableFriendlyType(p.SqlType, null);
            var memberName=DalUtils.ToPascalCase(p.Name);
#>
        <#= memberType #> _<#= memberName#>;
        [DataMember(Order = <#= p.Order #>)]
        public <#=memberType #> <#= memberName#> { get { return _GetNullableValue(_<#= memberName#>, <#= p.Order#>); } set { _<#= memberName#> = value; _SetNullable(_<#= memberName#>==null, <#= p.Order#>); } }
 
<#
        } //end foreach proc.Request.TVP params
#>

        #region nullable hack...
        private BitArray _InternalNullFields;
        private static int _MaxOrder=<#= param.TVP.Max(x=>x.Order) #>;
   
        [DataMember(Order = 10000)]
        public byte[] InternalNullFields { get{ return _InternalNullFields.ToBytes();} set{ if (value != null) { _InternalNullFields = new BitArray(value); } else { _InternalNullFields = null; }; } }

        private void _SetNullable(bool isNullValue, int order)
        {
            if (_InternalNullFields == null && !isNullValue) return;
            if (order > _MaxOrder) throw new Exception($"_SetNullable{order} is greater than MaxOrder: {_MaxOrder}");
            if (_InternalNullFields == null) _InternalNullFields = new BitArray(_MaxOrder);
            _InternalNullFields.Set(order-1, isNullValue);
        }

        private T? _GetNullableValue<T>(T? value, int order) where T: struct
        {
            if (order > _MaxOrder) throw new Exception($"_SetNullable Invalid Generation Order{order} is greater than max order{_MaxOrder} ");
            if (_InternalNullFields == null) return value.GetValueOrDefault();
            if (_InternalNullFields.Get(order-1)) return null;
            return value.GetValueOrDefault();
        }

        private T[] _GetNullableValue<T>(T[] value, int order) where T: struct
        {
            if (order > _MaxOrder) throw new Exception($"_SetNullable Invalid Generation Order{order} is greater than max order{_MaxOrder} ");
            if (_InternalNullFields == null) return value ?? Array.Empty<T>();
            if (_InternalNullFields.Get(order-1)) return null;
            return value ?? Array.Empty<T>();
        }

        private string _GetNullableValue(string value, int order)
        {
            if (order > _MaxOrder) throw new Exception($"_SetNullable Invalid Generation Order{order} is greater than max order{_MaxOrder} ");
            if (_InternalNullFields == null) return value ?? string.Empty;
            if (_InternalNullFields.Get(order-1)) return null;
            return value ?? string.Empty;
        }
        #endregion
    }
    #endregion

<#
    } //end foreach proc.Request.TVP
} //end foreach dbMeta.Procedures
#> 
}
